本文对C++变量和表达式部分的巩固，其中众所周知的基本常识就免了，我记录的是在读《C++ Primer》过程中所看到的容易遗忘和难于记忆的C++知识点。
<!-- more -->

## 默认初始化
如果定义变量没有给定初始值，则变量被默认初始化，此时变量被赋予了“默认值”。

每个类各自决定其初始化对象的方式，而且，时候允许不仅初始化旧定义对象也由类的实现决定。

如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义与任何函数之外的变量被初始化为0，定义在函数体内部的内置类型将**不被初始化**。

<!-- class="alert alert-success" -->
建议初始化每一个内置类型的变量。虽然并非必要这么做，但如果我们不能确保初始化后程序安全，那么这么做不失为一种简单可靠的方法。
<!-- endclass -->

#### 变量声明和定义
变量声明规定了变量的类型和名字，在这一点上定义与之相同。但除此之外，定义还申请储存空间，也可能为变量赋一个初始值。
```c++
extern int i; // 声明 i 而非定义 i
int j;        // 声明并定义 j
extern double pi = 3.1416;  // 定义 pi
```
### const限定符
因为const对象一旦被创建后其值旧不能再改变，所以const对象必须初始化。
**默认状态下，const对象进在文件内有效**，解决办法是，对于const变量不管是声明还是定义都添加`extern`关键字，这样只需定义一次就可以了。

#### const 和指针
##### 指向常量的指针，底层const：
```c++
int i = 3;
const int *p = &i;
*p = 3; // 错误
int i2 = 4;
p = &i2; // 正确
```
##### 常量指针，顶层const
```c++
int i = 3;
int* const p = &i;
*p = 3; // 正确
int i2 = 4;
p = &i2; // 错误
```

**顶层const**（top-level const）表示指针本身是一个常量，而**底层const**（low-level const）表示指针或引用所指的对象是常量。更为一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都使用；底层const则与指针和引用等符合类型的基本类型部分有关。
```c++
const int *const p3 = p2; // 靠右的const是顶层，靠左的是底层const
const int &r = ci;        // 用于声明引用的const都是底层const
```



<!-- class="alert alert-success" -->
变量能且只能被定义一次，但是可以被多次声明。
<!-- endclass -->

#### 递增和递减运算符

前置和后置版本的不同在于，前置版首先将运算对象加1（或减1），然后讲改变后的对象作为求值结果，后置版本也会将运算对象加1（或减1），但是求值结果是运算对象改变之前的那个值的副本。

```c++
int i = 0, j;
j = ++i;    // j = 1， i = 1: 前置版本得到递增之后的值
j = i++     // j = 1,  i = 2: 后置版本得到递增之前的值
```

* 除非必要，否则不用递增递减运算符的后置版本

* 后置递增运算符经典案例：在一条语句中混用解引用和递增运算符
```c++
auto pbeg = v.begin();
// 输出元素直至遇到第一个负值为止
while ( pbeg != v.end() && *pbeg >= 0 )
    cout << *pbeg++ << endl;
```
